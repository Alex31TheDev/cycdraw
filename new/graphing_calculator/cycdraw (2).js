const f_1 = {
    0: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255,
            255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255,
            255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
        ]
    },
    1: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
        ]
    },
    2: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255,
            255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
        ]
    },
    3: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255,
            255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
        ]
    },
    4: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255,
            255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255
        ]
    },
    5: {
        w: 5,
        h: 7,
        pixels: [
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
        ]
    },
    6: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
        ]
    },
    7: {
        w: 5,
        h: 7,
        pixels: [
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,
            255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0
        ]
    },
    8: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
        ]
    },
    9: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0
        ]
    },
    unknown: {
        w: 5,
        h: 7,
        pixels: [
            0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0
        ]
    }
};

class Color {
    constructor(r, g, b, a) {
        if (r instanceof Color) {
            this.r = r.r;
            this.g = r.g;
            this.b = r.b;
            this.a = r.a;
        } else {
            this.r = Math.min(Math.max(Math.round(r), 0), 255);
            this.g = Math.min(Math.max(Math.round(g), 0), 255);
            this.b = Math.min(Math.max(Math.round(b), 0), 255);
            this.a = Math.min(Math.max(Math.round(a), 0), 255);

            this.r = isNaN(this.r) ? 255 : this.r;
            this.g = isNaN(this.g) ? 255 : this.g;
            this.b = isNaN(this.b) ? 255 : this.b;
            this.a = isNaN(this.a) ? 255 : this.a;
        }
    }
}

const Colors = Object.freeze({
    aqua: new Color(0, 255, 255, 255),
    beige: new Color(245, 245, 220, 255),
    black: new Color(0, 0, 0, 255),
    blue: new Color(0, 0, 255, 255),
    brown: new Color(165, 42, 42, 255),
    clr69: new Color(69, 96, 69, 255),
    crimson: new Color(220, 20, 60, 255),
    cyan: new Color(0, 255, 255, 255),
    darkBlue: new Color(0, 0, 139, 255),
    darkCyan: new Color(0, 139, 139, 255),
    darkGray: new Color(169, 169, 169, 255),
    darkGreen: new Color(0, 100, 0, 255),
    darkOrange: new Color(255, 140, 0, 255),
    darkRed: new Color(139, 0, 0, 255),
    deepPink: new Color(255, 20, 147, 255),
    gold: new Color(255, 215, 0, 255),
    gray: new Color(128, 128, 128, 255),
    green: new Color(0, 128, 0, 255),
    hotPink: new Color(255, 105, 180, 255),
    indigo: new Color(75, 0, 130, 255),
    lightBlue: new Color(173, 216, 230, 255),
    lightCyan: new Color(224, 255, 255, 255),
    lightGray: new Color(211, 211, 211, 255),
    lightGreen: new Color(144, 238, 144, 255),
    lightPink: new Color(255, 182, 193, 255),
    lightYellow: new Color(255, 255, 224, 255),
    lime: new Color(0, 255, 0, 255),
    magenta: new Color(255, 0, 255, 255),
    olive: new Color(128, 128, 0, 255),
    orange: new Color(255, 165, 0, 255),
    orangeRed: new Color(255, 69, 0, 255),
    pink: new Color(255, 192, 203, 255),
    purple: new Color(147, 112, 219, 255),
    red: new Color(255, 0, 0, 255),
    silver: new Color(192, 192, 192, 255),
    tan: new Color(210, 180, 140, 255),
    violet: new Color(138, 43, 226, 255),
    white: new Color(255, 255, 255, 255),
    yellow: new Color(255, 255, 0, 255)
});

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static fromPolar(phase, length) {
        return new Point(length * Math.cos(phase), length * Math.sin(phase));
    }

    toString() {
        return `Point: {x: ${this.x}, y: ${this.y}}`;
    }

    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}

class Font {
    constructor(charSet, spacing = 0, postProc) {
        this.spacing = spacing;
        this.loadGlyphs(charSet);

        if (typeof postProc !== "undefined") {
            const glyphs = this.charSet.map(x => this.charMap[x]);
            glyphs.forEach(postProc);

            postProc(this.unknown);
        }
    }

    loadGlyphs(charSet) {
        this.charSet = Object.keys(charSet);
        this.charMap = {};

        this.unknown = undefined;

        for (const key of Object.keys(charSet)) {
            const char = charSet[key],
                glyph = Image.fromArray(char.pixels, char.w, char.h);

            if (key === "unknown") {
                this.unknown = glyph;

                const ind = this.charSet.indexOf(key);
                this.charSet.splice(ind, 1);
            } else {
                this.charMap[key] = glyph;
            }
        }

        if (typeof this.unknown === "undefined") {
            this.unknown = new Image(1, 1);
        }
    }

    getGlyph(char) {
        if (this.charSet.includes(char)) {
            return this.charMap[char];
        }

        return this.unknown;
    }
}

class Image {
    constructor(w, h) {
        if (w <= 0 || h <= 0) {
            throw new DrawingError("Invalid image size.");
        }

        this.w = Math.floor(w);
        this.h = Math.floor(h);

        this.pixels = new Uint8Array(w * h * 3).fill(0);
    }

    static fromArray(pixels, w, h) {
        if (pixels.length % 3 != 0) {
            throw new DrawingError("Pixel array invalid.");
        }

        if (pixels.length > w * h * 3) {
            throw new DrawingError("Pixel array too large.");
        }

        let img = new Image(w, h);
        let i = 0;
        for (; i < pixels.length; i++) {
            img.pixels[i] = pixels[i] & 0xff;
        }

        return img;
    }

    encode() {
        return new EncoderPNG(this.pixels, this.w, this.h).encode();
    }

    getPixel(x, y) {
        if (!this.inBounds(x, y)) {
            return Colors.clr69;
        }

        x = Math.floor(x);
        y = Math.floor(y);

        let pos = 3 * (y * this.w + x);

        return new Color(this.pixels[pos], this.pixels[pos + 1], this.pixels[pos + 2]);
    }

    setPixel(x, y, color) {
        if (!this.inBounds(x, y)) {
            return;
        }

        this.setPixel_u(Math.floor(x), Math.floor(y), color);
    }

    setPixel_u(x, y, color) {
        let pos = 3 * (y * this.w + x);

        this.pixels[pos++] = color.r;
        this.pixels[pos++] = color.g;
        this.pixels[pos] = color.b;
    }

    setPixel_u_rgb(x, y, r, g, b) {
        let pos = 3 * (y * this.w + x);

        this.pixels[pos++] = r;
        this.pixels[pos++] = g;
        this.pixels[pos] = b;
    }

    clear(color) {
        let i = 0;

        while (i < this.pixels.length) {
            this.pixels[i++] = color.r;
            this.pixels[i++] = color.g;
            this.pixels[i++] = color.b;
        }
    }

    blit(x, y, src, w, h) {
        let sw = Math.min(w, src.w) || src.w,
            sh = Math.min(h, src.h) || src.h;

        if (sw + x >= this.w) {
            sw = this.w - x;
        }
        if (sh + y >= this.h) {
            sh = this.h - y;
        }

        for (let i = 0; i < sw; i++) {
            for (let j = 0; j < sh; j++) {
                let pos1 = 3 * ((j + y) * this.w + i + x);
                let pos2 = 3 * (j * src.w + i);

                this.pixels[pos1] = src.pixels[pos2];
                this.pixels[pos1 + 1] = src.pixels[pos2 + 1];
                this.pixels[pos1 + 2] = src.pixels[pos2 + 2];
            }
        }
    }

    invert() {
        let i = 0;

        for (; i < this.pixels.length; i++) {
            this.pixels[i] = ~this.pixels[i];
        }
    }

    removeChannel(channel) {
        let i = 0;

        switch (channel) {
            case "r":
                break;
            case "g":
                i = 1;
                break;
            case "b":
                i = 2;
                break;
            default:
                return;
        }

        for (; i < this.pixels.length; i += 3) {
            this.pixels[i] = 0;
        }
    }

    fill(x1, y1, x2, y2, color) {
        if ((x1 < 0 && x2 < 0) || (x1 > this.w && x2 > this.w) || (y1 < 0 && y2 < 0) || (y1 > this.h && y2 > this.h)) {
            return;
        }

        [x1, y1] = this.clamp(x1, y1);
        [x2, y2] = this.clamp(x2, y2);

        if (x2 < x1) {
            let tmp = x1;
            x1 = x2;
            x2 = tmp;
        }

        if (y2 < y1) {
            let tmp = y1;
            y1 = y2;
            y2 = tmp;
        }

        let w = Math.abs(x2 - x1);
        let h = Math.abs(y2 - y1);

        if (w == 0 && h == 0) {
            this.setPixel_u(x1, y1, color);
        } else if (h == 0) {
            let pos1 = 3 * (y1 * this.w + x1);
            let pos2 = 3 * (y2 * this.w + x2);

            while (pos1 <= pos2) {
                this.pixels[pos1++] = color.r;
                this.pixels[pos1++] = color.g;
                this.pixels[pos1++] = color.b;
            }
        } else if (w == 0) {
            let yi = 3 * (this.w - 1);

            let pos1 = 3 * (y1 * this.w + x1);
            let pos2 = 3 * (y2 * this.w + x2);

            while (pos1 <= pos2) {
                this.pixels[pos1++] = color.r;
                this.pixels[pos1++] = color.g;
                this.pixels[pos1++] = color.b;

                pos1 += yi;
            }
        } else {
            let yi = -3 * (w - this.w + 1);

            let i = 0,
                j;
            let pos = 3 * (y1 * this.w + x1);

            for (; i <= h; i++) {
                for (j = 0; j <= w; j++) {
                    this.pixels[pos++] = color.r;
                    this.pixels[pos++] = color.g;
                    this.pixels[pos++] = color.b;
                }

                pos += yi;
            }
        }
    }

    drawLine(x1, y1, x2, y2, color) {
        if (x1 == x2 && y1 == y2) {
            this.setPixel_u(x1, y1, color);
            return;
        }

        let coords = this.clampLiangBarsky(x1, y1, x2, y2);
        if (!coords) {
            return;
        }

        [x1, y1, x2, y2] = coords;

        let dx = x2 - x1;
        let dy = y2 - y1;

        if (dx == 0 && dy == 0) {
            this.setPixel_u(x1, y1, color);
        } else if (dy == 0) {
            let pos1 = 3 * (y1 * this.w + x1);
            let pos2 = 3 * (y2 * this.w + x2);

            if (pos1 > pos2) {
                let tmp = pos1;
                pos1 = pos2;
                pos2 = tmp;
            }

            while (pos1 <= pos2) {
                this.pixels[pos1++] = color.r;
                this.pixels[pos1++] = color.g;
                this.pixels[pos1++] = color.b;
            }
        } else if (dx == 0) {
            let yi = 3 * (this.w - 1);

            let pos1 = 3 * (y1 * this.w + x1);
            let pos2 = 3 * (y2 * this.w + x2);

            if (pos1 > pos2) {
                let tmp = pos1;
                pos1 = pos2;
                pos2 = tmp;
            }

            while (pos1 <= pos2) {
                this.pixels[pos1++] = color.r;
                this.pixels[pos1++] = color.g;
                this.pixels[pos1++] = color.b;

                pos1 += yi;
            }
        } else if (Math.abs(dy) < Math.abs(dx)) {
            if (x1 > x2) {
                let tmp = x2;
                x2 = x1;
                x1 = tmp;

                tmp = y2;
                y2 = y1;
                y1 = tmp;

                dx = -dx;
                dy = -dy;
            }

            let yi = 3 * this.w;
            if (dy < 0) {
                yi = -yi;
                dy = -dy;
            }

            let err = 2 * dy - dx;
            let derr1 = -2 * dx;
            let derr2 = 2 * dy;

            let pos = 3 * (y1 * this.w + x1);

            for (; x1 <= x2; x1++) {
                this.pixels[pos++] = color.r;
                this.pixels[pos++] = color.g;
                this.pixels[pos++] = color.b;

                if (err >= 0) {
                    pos += yi;
                    err += derr1;
                }

                err += derr2;
            }
        } else {
            if (y1 > y2) {
                let tmp = x2;
                x2 = x1;
                x1 = tmp;

                tmp = y2;
                y2 = y1;
                y1 = tmp;

                dx = -dx;
                dy = -dy;
            }

            let xi = 3;
            let yi = 3 * (this.w - 1);
            if (dx < 0) {
                xi = -xi;
                dx = -dx;
            }

            let err = 2 * dx - dy;
            let derr1 = -2 * dy;
            let derr2 = 2 * dx;

            let pos = 3 * (y1 * this.w + x1);

            for (; y1 <= y2; y1++) {
                this.pixels[pos++] = color.r;
                this.pixels[pos++] = color.g;
                this.pixels[pos++] = color.b;

                if (err >= 0) {
                    pos += xi;
                    err += derr1;
                }

                err += derr2;
                pos += yi;
            }
        }
    }

    circleBres(xc, yc, r, color) {
        function circlePoints(img, xc, yc, x, y) {
            img.setPixel(xc + x, yc + y, color);
            img.setPixel(xc - x, yc + y, color);
            img.setPixel(xc + x, yc - y, color);
            img.setPixel(xc - x, yc - y, color);
            img.setPixel(xc + y, yc + x, color);
            img.setPixel(xc - y, yc + x, color);
            img.setPixel(xc + y, yc - x, color);
            img.setPixel(xc - y, yc - x, color);
        }

        let x = 0,
            y = r,
            d = 3 - 2 * r;

        circlePoints(this, xc, yc, x, y);

        while (y >= x) {
            x++;
            if (d > 0) {
                y--;
                d = d + 4 * (x - y) + 10;
            } else {
                d = d + 4 * x + 6;
            }

            circlePoints(this, xc, yc, x, y);
        }
    }

    drawString(x, y, str, font) {
        let x_of = 0;

        for (let i = 0; i < str.length; i++) {
            const char = str[i];

            if (char === "\n") {
                continue;
            }

            const glyph = font.getGlyph(char);
            this.blit(x + x_of, y, glyph);

            x_of += glyph.w + font.spacing;
        }
    }

    inBounds(x, y) {
        return x >= 0 && x < this.w && y >= 0 && y < this.h;
    }

    clamp(x, y) {
        x = Math.min(Math.max(x, 0), this.w - 1);
        y = Math.min(Math.max(y, 0), this.h - 1);
        return [Math.floor(x), Math.floor(y)];
    }

    clampLiangBarsky(x0src, y0src, x1src, y1src) {
        if (this.inBounds(x0src, y0src) && this.inBounds(x1src, y1src)) {
            return [Math.floor(x0src), Math.floor(y0src), Math.floor(x1src), Math.floor(y1src)];
        }

        const edgeLeft = 0,
            edgeRight = this.w,
            edgeBottom = 0,
            edgeTop = this.h;

        y0src = this.h - 1 - y0src;
        y1src = this.h - 1 - y1src;

        let t0 = 0.0;
        let t1 = 1.0;
        let xdelta = x1src - x0src;
        let ydelta = y1src - y0src;
        let p, q, r;

        for (let edge = 0; edge < 4; edge++) {
            switch (edge) {
                case 0:
                    p = -xdelta;
                    q = -(edgeLeft - x0src);
                    break;
                case 1:
                    p = xdelta;
                    q = edgeRight - x0src;
                    break;
                case 2:
                    p = -ydelta;
                    q = -(edgeBottom - y0src);
                    break;
                case 3:
                    p = ydelta;
                    q = edgeTop - y0src;
                    break;
            }

            r = q / p;
            if (p == 0 && q < 0) return false;

            if (p < 0) {
                if (r > t1) return false;
                else if (r > t0) t0 = r;
            } else if (p > 0) {
                if (r < t0) return false;
                else if (r < t1) t1 = r;
            }
        }

        let x0clip = Math.floor(x0src + t0 * xdelta),
            y0clip = Math.floor(y0src + t0 * ydelta),
            x1clip = Math.floor(x0src + t1 * xdelta),
            y1clip = Math.floor(y0src + t1 * ydelta);

        return [x0clip, y0clip, x1clip, y1clip];
    }
}

class Buffer2 extends Uint8Array {
    static alloc(size) {
        return new Buffer2(size);
    }

    toString(viewSize = 32) {
        const lenChars = this.length.toString().length;
        let str = `Buffer2 Size: ${this.length} bytes`;

        let len = this.length,
            i = 0;

        while (len) {
            let chunkLen = Math.min(len, viewSize);
            len -= chunkLen;

            str += `\n${i.toString().padEnd(lenChars, " ")} - [ `;
            let view = "";

            while (chunkLen--) {
                const hex = this[i++].toString(16);
                view += ("0" + hex).slice(-2) + " ";
            }

            str += `${view.padEnd(3 * viewSize, ";")}] - ${i - 1}`;
        }

        return str;
    }

    inspect(depth, opts) {
        return this.toString();
    }

    writeUInt32BE(value, offset) {
        this[offset] = (value >> 24) & 0xff;
        this[offset + 1] = (value >> 16) & 0xff;
        this[offset + 2] = (value >> 8) & 0xff;
        this[offset + 3] = value & 0xff;
    }

    writeUInt16LE(value, offset) {
        this[offset] = value & 0xff;
        this[offset + 1] = (value >> 8) & 0xff;
    }

    write(value, offset, a) {
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            this[offset++] = code & 0xff;
        }
    }

    blit(src, offset, start, length) {
        if (offset >= this.length || start >= src.length) {
            return;
        }

        if (length + offset >= this.length || length + start >= src.length) {
            length = Math.min(this.length - offset, src.length - start);
        }

        for (let i = 0; i < length; i++) {
            this[i + offset] = src[i + start] & 0xff;
        }
    }

    writeCRC32(start, end) {
        let crc = CRC32.checksum(this, start, end);
        this.writeUInt32BE(crc, end);
    }
}

const Adler32 = {
    checksum: function (buf, start, end) {
        let a = 1,
            b = 0;

        let len = end,
            i = start;

        while (len) {
            let chunkLen = Math.min(len, 4096);
            len -= chunkLen;

            while (chunkLen--) {
                a += buf[i++];
                b += a;
            }

            a %= 65521;
            b %= 65521;
        }

        const sum = (b << 16) | a;
        return sum >>> 0;
    }
};

const CRC32 = {
    makeTable: function () {
        const table = Array(256);

        for (let n = 0; n < 256; n++) {
            let c = n;

            for (let k = 0; k < 8; k++) {
                c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
            }

            table[n] = c;
        }

        return table;
    },

    checksum: function (buf, start, end) {
        if (!CRC32.table) {
            CRC32.table = CRC32.makeTable();
        }

        let crc = 0 ^ -1;

        for (let i = start; i < end; i++) {
            crc = (crc >>> 8) ^ this.table[(crc ^ buf[i]) & 0xff];
        }

        return (crc ^ -1) >>> 0;
    }
};

class ChunkPNG {
    constructor(name) {
        if (name.length != 4) {
            throw new Error("Invalid chunk name.");
        }

        this.name = name;

        this.data = [];
        this.types = [];
    }

    addData(data, type) {
        this.data.push(data);
        this.types.push(type);
    }

    getSize() {
        let size = 12;

        for (let i = 0; i < this.data.length; i++) {
            switch (this.types[i]) {
                case 0:
                    size += 4;
                    break;
                case 3:
                    size++;
                    break;
                default:
                    size += this.data[i].length;
                    break;
            }
        }

        return size;
    }
}

class EncoderPNG {
    constructor(pixels, w, h) {
        if (!pixels instanceof Uint8Array) {
            throw new Error("Invalid pixel array type.");
        }

        if (pixels.length != 3 * w * h) {
            throw new Error("Pixel array size invalid.");
        }

        this.pixels = pixels;

        this.w = w;
        this.h = h;

        this.offset = 0;
        this.chunks = [];
    }

    filterPixels() {
        let d1 = Date.now();
        let buf = Buffer2.alloc(this.pixels.length + this.h);

        for (let y = 0; y < this.h; y++) {
            buf[y * this.w * 3 + y] = 1;

            for (let x = 0; x < this.w; x++) {
                let pos = 3 * (y * this.w + x);
                let pos_b = pos + y;
                let r_f, g_f, b_f;

                if (x == 0) {
                    r_f = this.pixels[pos];
                    g_f = this.pixels[pos + 1];
                    b_f = this.pixels[pos + 2];
                } else {
                    r_f = this.pixels[pos] - this.pixels[pos - 3];
                    g_f = this.pixels[pos + 1] - this.pixels[pos - 2];
                    b_f = this.pixels[pos + 2] - this.pixels[pos - 1];
                }

                buf[pos_b + 1] = r_f;
                buf[pos_b + 2] = g_f;
                buf[pos_b + 3] = b_f;
            }
        }

        this.pixels = buf;
        benchmark["enc_filter"] = Date.now() - d1;
    }

    compressPixels() {
        const zlib = new Zlib(this.pixels);
        this.pixels = zlib.deflate(2);
    }

    getChunksSize() {
        let size = 0;
        this.sizes = Array(this.chunks.length);

        for (let i = 0; i < this.chunks.length; i++) {
            const chunkSize = this.chunks[i].getSize();

            size += chunkSize;
            this.sizes[i] = chunkSize;
        }

        return size;
    }

    writeChunks() {
        for (let i = 0; i < this.chunks.length; i++) {
            const chunk = this.chunks[i],
                size = this.sizes[i];

            this.buf.writeUInt32BE(size - 12, this.offset);
            this.buf.write(chunk.name, this.offset + 4);
            this.offset += 8;

            for (let j = 0; j < chunk.data.length && size > 0; j++) {
                switch (chunk.types[j]) {
                    case 0:
                        this.buf.writeUInt32BE(chunk.data[j], this.offset);
                        this.offset += 4;
                        break;
                    case 1:
                        this.buf.write(chunk.data[j], this.offset);
                        this.offset += chunk.data[j].length;
                        break;
                    case 2:
                        this.buf.blit(chunk.data[j], this.offset, 0, chunk.data[j].length);
                        this.offset += chunk.data[j].length;
                        break;
                    case 3:
                        this.buf[this.offset++] = chunk.data[j];
                        break;
                }
            }

            this.buf.writeCRC32(this.offset - size + 8, this.offset);
            this.offset += 4;
        }
    }

    encode() {
        this.filterPixels();
        this.compressPixels();

        const ihdr = new ChunkPNG("IHDR");
        ihdr.addData(this.w, 0);
        ihdr.addData(this.h, 0);
        ihdr.addData("\x08\x02\x00\x00\x00", 1);

        const idat = new ChunkPNG("IDAT");
        idat.addData(this.pixels, 2);

        const iend = new ChunkPNG("IEND");

        this.chunks.push(ihdr);
        this.chunks.push(idat);
        this.chunks.push(iend);

        const sigSize = 8;
        this.buf = new Buffer2(this.getChunksSize() + sigSize);

        this.buf.write("\x89PNG\x0d\x0a\x1a\x0a", 0);
        this.offset += sigSize;

        this.writeChunks();

        return this.buf;
    }
}

class Zlib {
    constructor(data) {
        if (!(data instanceof Buffer2 || data instanceof Uint8Array)) {
            throw new Error("Invalid data array type.");
        }

        this.data = data;
    }

    blurredCompress() {
        const chunks = Math.ceil(this.data.length / 65535);

        const buf = Buffer2.alloc(this.data.length + 6 + 5 * chunks);
        buf.write("\x78\x01", 0);

        let len = this.data.length,
            i = 2,
            doffset = 0;

        while (len) {
            const chunkLen = Math.min(len, 65535);
            len -= chunkLen;

            buf[i] = len ? 0 : 1;

            buf.writeUInt16LE(chunkLen, i + 1);
            buf.writeUInt16LE(~chunkLen, i + 3);

            buf.blit(this.data, i + 5, doffset, chunkLen);

            i += chunkLen + 5;
            doffset += chunkLen;
        }

        const sum = Adler32.checksum(this.data, 0, this.data.length);
        buf.writeUInt32BE(sum, i);

        this.data = buf;
    }

    dynamicHuffmannDeflate() {}

    nodejsDeflate() {
        const zlib = require("zlib");

        const buf = zlib.deflateSync(Buffer.from(this.data));
        this.data = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }

    deflate(ctype) {
        let d1 = Date.now();

        switch (ctype) {
            case 0:
                this.blurredCompress();
                break;
            case 1:
                this.dynamicHuffmannDeflate();
                break;
            case 2:
                this.nodejsDeflate();
                break;
            default:
                throw new Error("Invalid compression type.");
        }

        benchmark["enc_compress"] = Date.now() - d1;
        return this.data;
    }
}

let benchmark = {};

writeImg();

function writeImg() {
    const fs = require("fs");

    let d1 = Date.now(),
        d2 = Date.now();
    let w = 720,
        h = 480;

    let img = new Image(w, h);
    benchmark["create_img"] = Date.now() - d1;
    d1 = Date.now();

    drawImg(img);

    benchmark["draw_img"] = Date.now() - d1;
    d1 = Date.now();
    let buf = img.encode();
    benchmark["encode_img"] = Date.now() - d1;

    d1 = Date.now();
    fs.writeFileSync("./amongus1.png", Buffer.from(buf));
    benchmark["write_file"] = Date.now() - d1;

    benchmark["total"] = Date.now() - d2;
    console.log(benchmark);
    console.log(img.pixels);
}

function drawAxis(
    img,
    xOffset,
    yOffset,
    unit,
    axisColor,
    originColor,
    pointColor,
    axisThickness,
    originRadius,
    pointRadius,
    font,
    textSpacing
) {
    for (let i = -Math.floor(axisThickness / 2); i <= Math.floor(axisThickness / 2); i++) {
        img.drawLine(0, img.h / 2 + i + yOffset, img.w - 1, img.h / 2 + i + yOffset, axisColor);
        img.drawLine(img.w / 2 + i + xOffset, 0, img.w / 2 + i + xOffset, img.h - 1, axisColor);
    }

    img.circleBres(img.w / 2 + xOffset, img.h / 2 + yOffset, originRadius, originColor);
    img.drawString(img.w / 2 + textSpacing + xOffset, img.h / 2 + textSpacing + yOffset, "0", font);

    let step = 0;
    for (let i = unit; i < img.w / 2 + xOffset; i += unit) {
        img.circleBres(img.w / 2 + i + xOffset, img.h / 2 + yOffset, pointRadius, pointColor);
        img.circleBres(img.w / 2 - i + xOffset, img.h / 2 + yOffset, pointRadius, pointColor);

        step++;
        const num = step.toString();

        img.drawString(img.w / 2 + i + textSpacing + xOffset, img.h / 2 + textSpacing + yOffset, num, font);
    }

    step = 0;
    for (let i = unit; i < img.h / 2 + yOffset; i += unit) {
        img.circleBres(img.w / 2 + xOffset, img.h / 2 + i + yOffset, pointRadius, pointColor);
        img.circleBres(img.w / 2 + xOffset, img.h / 2 - i + yOffset, pointRadius, pointColor);

        step++;
        const num = step.toString();

        img.drawString(img.w / 2 + textSpacing + xOffset, img.h / 2 - i + textSpacing + yOffset, num, font);
    }
}

function drawGrid(img, xOffset, yOffset, unit, lineColor) {
    for (let i = unit; i < img.w / 2 + xOffset; i += unit) {
        img.drawLine(img.w / 2 + i + xOffset, 0, img.w / 2 + i + xOffset, img.h - 1, lineColor);
        img.drawLine(img.w / 2 - i + xOffset, 0, img.w / 2 - i + xOffset, img.h - 1, lineColor);
    }

    for (let i = unit; i < img.h / 2 + yOffset; i += unit) {
        img.drawLine(0, img.h / 2 + i + yOffset, img.w - 1, img.h / 2 + i + yOffset, lineColor);
        img.drawLine(0, img.h / 2 - i + yOffset, img.w - 1, img.h / 2 - i + yOffset, lineColor);
    }
}

function drawGraph(img, xOffset, yOffset, unit, graphColor, graphThickness, f) {
    return;
}

function f(x) {
    return x;
}

function drawImg(img) {
    const unit = 100;

    const backgroundColor = Colors.white,
        axisColor = Colors.black,
        originColor = Colors.lightBlue,
        pointColor = Colors.darkRed,
        gridColor = Colors.gray,
        subGridColor = Colors.lightGray,
        graphColor = Colors.blue;

    const xOffset = 100,
        yOffset = 100;

    const axisThickness = 1,
        originRadius = 3,
        pointRadius = 2,
        textSpacing = 3,
        graphThickness = 2;

    const font = new Font(f_1, 0, glyph => glyph.invert());

    img.clear(backgroundColor);

    drawGrid(img, xOffset, yOffset, unit / 4, subGridColor);
    drawGrid(img, xOffset, yOffset, unit / 2, subGridColor);
    drawGrid(img, xOffset, yOffset, unit, gridColor);

    drawAxis(
        img,
        xOffset,
        yOffset,
        unit,
        axisColor,
        originColor,
        pointColor,
        axisThickness,
        originRadius,
        pointRadius,
        font,
        textSpacing
    );
    drawGraph(img, xOffset, yOffset, unit, graphColor, graphThickness, f);
}
